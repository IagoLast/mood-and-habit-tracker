## Internationalization

This guide covers i18n conventions and patterns for scalable applications. It assumes familiarity with i18next and focuses on architectural decisions and naming conventions.

### Namespace Constants

All translation namespaces are defined as constants in `src/constants/namespaces.ts`. This centralized approach prevents typos and makes refactoring easier.

```typescript
export const NS_REGISTER = "register";
export const NS_CUSTOMER_DETAILS = "customer-details";
export const NS_LIBRARY = "ns-library";
export const NS_DASHBOARD_INDEX = "ns-dashboard";
export const NS_PROFILE = "ns-profile";
export const NS_CHAT = "ns-chat";
```

Always import and use these constants instead of hardcoding namespace strings:

```typescript
// ✅ Good
import { NS_CUSTOMER_DETAILS } from "@/constants/namespaces";
await i18n.loadNamespaces([NS_CUSTOMER_DETAILS]);

// ❌ Bad
await i18n.loadNamespaces(["customer-details"]);
```

### File Naming Convention

Translation files follow the `ns-[feature-name].json` naming pattern to maintain consistency and avoid conflicts:

```
public/locales/
├── en/
│   ├── ns-login.json
│   ├── ns-dashboard.json
│   ├── ns-create-account.json
└── es/
    └── [mirrors en structure]
```

**Note**: Legacy files may not follow this convention and should be migrated to the `ns-` prefix pattern when possible.

### Translation Keys as English Text

Translation keys are the actual English text, not arbitrary identifiers. This approach eliminates the need for intermediate mapping and makes the code self-documenting.

```json
{
  "Add exercise": "Añadir ejercicio",
  "Add form": "Añadir formulario",
  "Cancel": "Cancelar",
  "Save": "Guardar",
  "Are you sure?": "¿Estás seguro?",
  "Profile updated successfully": "Perfil actualizado correctamente"
}
```

**Benefits:**

- No mental mapping between keys and content
- English fallback is automatic when translations are missing
- Code is readable without consulting translation files
- Easier for non-technical team members to understand

### Using Translations in Code

Import the `t` function directly from i18next instead of using React hooks:

```typescript
import { t } from "i18next";

export function MyComponent() {
  const ns = "ns-customer-details";

  return (
    <div>
      <h1>{t("Customer Profile", { ns })}</h1>
      <button>{t("Save", { ns })}</button>
      <p>{t("Profile updated successfully", { ns })}</p>
    </div>
  );
}
```

This approach:

- Works in any JavaScript context (not just React components)
- Simplifies testing and debugging
- Reduces bundle size slightly
- Maintains consistency across the codebase

### Route-Level Namespace Loading

Namespaces are preloaded in route loaders to ensure translations are available before component rendering:

```typescript
// In route files
import { NS_CUSTOMER_DETAILS } from "@/constants/namespaces";
import i18next from "i18next";

export const customerDetailsRoute: RouteObject = {
  path: ROUTE_CUSTOMER_DETAILS,
  element: <CustomerDetailsPage />,
  loader() {
    return i18next.loadNamespaces([NS_CUSTOMER_DETAILS]).then(() => null);
  },
};
```

For multiple namespaces, load them in parallel:

```typescript
async loader() {
  await Promise.all([
    i18next.loadNamespaces([NS_DASHBOARD_INDEX, NS_PROFILE])
  ]);
  return null;
}
```

### Best Practices

#### Namespace Organization

- One namespace per major application section
- Use descriptive, feature-based names
- Prefix with `ns-` to follow convention

#### Translation Keys

- Use complete, natural English sentences
- Maintain consistent terminology across the app
- Keep keys concise but descriptive

#### File Management

- Keep translation files small and focused
- Update all language files simultaneously
- Review translations for consistency and accuracy

These conventions ensure maintainable, scalable internationalization while leveraging the natural fallback behavior of using English keys.

